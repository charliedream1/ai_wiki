本文由元宝AI生成

要理解 Python 中的协程，我们可以从**“可暂停、可恢复的函数”**这个核心出发，用**生活类比+代码实例**逐步拆解，避免抽象术语。


### **一、先抛开“异步”，用“接力赛”理解协程的本质**  
想象一场接力赛：4个运动员（A、B、C、D）跑400米，每人跑100米后把接力棒交给下一个人。这里的关键是：**每个人跑完自己的100米后，主动停下来，等下一个人接棒再继续**。  

**协程就像这个“运动员”**：它是一个函数（或代码块），可以在执行中**主动暂停**（把接力棒交给别人），并在之后**从暂停处恢复执行**（接过接力棒继续跑）。  

- **暂停**：通过 `yield`（生成器）或 `await`（异步协程）实现，记录当前执行位置（状态）。  
- **恢复**：通过 `next()`（生成器）或事件循环调度（异步协程）回到暂停处继续执行。  


### **二、Python 协程的两种形态：从“生成器”到“async/await”**  
Python 的协程发展有两个阶段：**同步协程（生成器）** 和 **异步协程（async/await）**。前者是“老协程”，后者是“新协程”，但核心都是“可暂停恢复”。


#### **1. 同步协程：用“生成器”实现（Python 2.5+）**  
生成器（`generator`）是 Python 早期的协程实现，通过 `yield` 关键字暂停执行，通过 `next()` 或 `send()` 恢复。  

**例：一个“计数协程”**  
```python
def count_coroutine():
    print("协程开始")
    n = 0
    while True:
        # 暂停：把n的值返回给调用方，并记住当前状态（n的值、循环位置）
        received = yield n  # received是调用方通过send()传进来的值
        if received is not None:
            n = received  # 用新值更新n
        else:
            n += 1
        print(f"协程计数: {n}")

# 1. 创建协程对象（此时函数未执行）
coro = count_coroutine()

# 2. 启动协程（执行到第一个yield暂停，返回n的初始值0）
print(next(coro))  # 输出：协程开始 → 0（暂停在yield n处）

# 3. 恢复协程：用send()传入新值，协程从暂停处继续
print(coro.send(10))  # 输出：协程计数: 10 → 10（暂停在下一个yield n处）
print(coro.send(None))  # 输出：协程计数: 11 → 11（n自增1后暂停）
print(coro.send(None))  # 输出：协程计数: 12 → 12
```  

**关键观察**：  
- 协程像“有记忆的函数”：每次暂停后，能记住 `n` 的值和循环位置，下次恢复时从那里继续。  
- 调度权在**调用方**：通过 `next()` 或 `send()` 主动“推”协程运行，协程自己不主动让出控制权（这是“同步”的原因）。  


#### **2. 异步协程：用“async/await”实现（Python 3.5+）**  
随着异步编程需求增长，Python 3.5 引入 `async/await` 语法，让协程更简洁地支持**异步I/O场景**（如网络请求、文件读写）。  

**核心变化**：  
- 用 `async def` 定义协程函数（代替生成器的 `def`）。  
- 用 `await` 代替 `yield`，表示“暂停并等待某个异步操作完成”（如 `await asyncio.sleep(1)`）。  
- 协程的调度由**事件循环（Event Loop）** 自动管理（代替手动 `next()`/`send()`）。  


**例：一个“异步计时协程”**  
```python
import asyncio

# 用async def定义异步协程
async def async_timer(name, seconds):
    print(f"[{name}] 开始计时 {seconds} 秒")
    # 暂停：等待异步操作（这里是sleep）完成，期间事件循环可调度其他协程
    await asyncio.sleep(seconds)  # 模拟I/O等待（如网络请求）
    print(f"[{name}] 计时结束！")
    return f"{name}的结果"

# 事件循环：调度协程执行
async def main():
    # 创建两个协程任务（并发执行）
    task1 = async_timer("任务1", 2)
    task2 = async_timer("任务2", 1)
    
    # 并发等待两个任务完成（事件循环自动切换协程）
    results = await asyncio.gather(task1, task2)
    print(f"所有结果: {results}")

# 启动事件循环
asyncio.run(main())
```  

**输出**：  
```
[任务1] 开始计时 2 秒
[任务2] 开始计时 1 秒
[任务2] 计时结束！  # 1秒后任务2先完成
[任务1] 计时结束！  # 再过1秒任务1完成
所有结果: ['任务1的结果', '任务2的结果']
```  

**关键观察**：  
- **事件循环是“裁判”**：它同时管理多个协程，当一个协程执行到 `await` 时（如等待2秒），事件循环会暂停它，去执行其他就绪的协程（如任务2的1秒等待）。  
- **协程“主动让出控制权”**：通过 `await` 显式告诉事件循环“我现在要等这个操作，你可以去干别的了”，这是“协作式调度”的核心。  


### **三、Python 协程的核心特点（对比函数/线程/进程）**  
| **特性**         | **普通函数**                | **协程（生成器/async）**       | **线程**                  | **进程**                  |  
|------------------|---------------------------|--------------------------------|-------------------------|-------------------------|  
| **执行方式**     | 一次性执行完（不可暂停）      | 可多次暂停/恢复（单线程内）      | 内核抢占式调度（可并行）   | 内核抢占式调度（可并行）   |  
| **调度权**       | 无（自动执行完）            | 用户态（主动yield/await让出）   | 操作系统（被动抢占）       | 操作系统（被动抢占）       |  
| **资源占用**     | 无额外开销                  | 极轻（KB级栈，动态扩缩）         | 较重（MB级栈，内核管理）   | 很重（独立内存，内核管理） |  
| **共享数据**     | 无（函数内局部变量）         | 同线程内共享（无需锁，单线程）   | 共享进程内存（需锁同步）   | 隔离内存（需IPC通信）     |  


### **四、为什么需要协程？（解决什么问题）**  
协程的核心价值是**在单线程内高效处理“多任务并发”**，尤其适合**I/O密集型场景**（如网络请求、文件读写）：  

- **普通函数**：执行一个I/O操作（如 `time.sleep(1)`）时会阻塞整个线程，期间CPU空闲。  
- **线程**：可并行多个I/O操作，但线程切换开销大（内核介入），且大量线程会耗尽资源。  
- **协程**：I/O等待时主动让出控制权，事件循环调度其他协程，CPU利用率接近100%，且资源占用极低（百万级协程仅需数百MB内存）。  


### **五、总结：Python 协程是什么？**  
**协程是 Python 中一种“可暂停、可恢复的用户态轻量级执行单元”**，通过 `yield`（生成器，同步）或 `async/await`（异步）实现，核心机制是**协作式调度**（主动让出控制权）。  

- **同步协程（生成器）**：用于单线程内任务切换（如惰性计算、迭代器），需手动调度（`next()`/`send()`）。  
- **异步协程（async/await）**：用于高并发I/O场景，由事件循环自动调度，是 `asyncio` 库的核心。  

**一句话概括**：协程让单线程“同时”做多件事，像“变魔术”一样高效，却不增加线程/进程的开销。